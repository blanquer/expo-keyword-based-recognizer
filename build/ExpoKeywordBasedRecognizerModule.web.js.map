{"version":3,"file":"ExpoKeywordBasedRecognizerModule.web.js","sourceRoot":"","sources":["../src/ExpoKeywordBasedRecognizerModule.web.ts"],"names":[],"mappings":"AAAA,YAAY;AACZ,sDAAsD;AACtD,gEAAgE;AAChE,iFAAiF;AACjF,gGAAgG;AAChG,0HAA0H;AAC1H,yBAAyB;AACzB,OAAO,EAAE,YAAY,EAAE,MAAM,MAAM,CAAC;AACpC,OAAO,EAKL,0BAA0B,EAC3B,MAAM,oCAAoC,CAAC;AAqC5C,iDAAiD;AAEjD,MAAM,gCAAiC,SAAQ,YAAoD;IACzF,WAAW,GAA6B,IAAI,CAAC;IAC7C,QAAQ,GAAG,KAAK,CAAC;IACjB,YAAY,GAAG,0BAA0B,CAAC,IAAI,CAAC;IAC/C,OAAO,GAAoC,IAAI,CAAC;IAChD,YAAY,GAAkB,IAAI,CAAC;IACnC,eAAe,GAAG,KAAK,CAAC;IACxB,gBAAgB,GAAG,EAAE,CAAC;IACtB,aAAa,GAAa,EAAE,CAAC,CAAC,uCAAuC;IACrE,aAAa,GAAkB,IAAI,CAAC,CAAC,wBAAwB;IAErE;QACE,KAAK,EAAE,CAAC;QACR,qFAAqF;IACvF,CAAC;IAEO,mBAAmB;QACzB,IAAI,CAAC,IAAI,CAAC,oBAAoB,EAAE,EAAE,CAAC;YACjC,OAAO,CAAC,IAAI,CAAC,qDAAqD,CAAC,CAAC;QACtE,CAAC;IACH,CAAC;IAEO,oBAAoB;QAC1B,kEAAkE;QAClE,IAAI,OAAO,MAAM,KAAK,WAAW,EAAE,CAAC;YAClC,OAAO,IAAI,CAAC;QACd,CAAC;QACD,OAAO,MAAM,CAAC,iBAAiB,IAAI,MAAM,CAAC,uBAAuB,IAAI,IAAI,CAAC;IAC5E,CAAC;IAEO,WAAW,CAAC,QAAoC;QACtD,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC;QAC7B,OAAO,CAAC,GAAG,CAAC,oCAAoC,QAAQ,aAAa,IAAI,CAAC,aAAa,EAAE,CAAC,CAAC;QAE3F,MAAM,SAAS,GAAQ,EAAE,KAAK,EAAE,QAAQ,EAAE,CAAC;QAC3C,IAAI,IAAI,CAAC,aAAa,EAAE,CAAC;YACvB,SAAS,CAAC,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC;QACxC,CAAC;QACD,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE,SAAS,CAAC,CAAC;IACxC,CAAC;IAEO,gBAAgB;QACtB,MAAM,sBAAsB,GAAG,IAAI,CAAC,oBAAoB,EAAE,CAAC;QAC3D,IAAI,CAAC,sBAAsB,EAAE,CAAC;YAC5B,MAAM,IAAI,KAAK,CAAC,qDAAqD,CAAC,CAAC;QACzE,CAAC;QAED,IAAI,CAAC,WAAW,GAAG,IAAI,sBAAsB,EAAE,CAAC;QAChD,6CAA6C;QAC7C,IAAI,CAAC,WAAW,CAAC,UAAU,GAAG,IAAI,CAAC,YAAY,KAAK,0BAA0B,CAAC,kBAAkB,CAAC;QAClG,IAAI,CAAC,WAAW,CAAC,cAAc,GAAG,KAAK,CAAC,CAAC,4BAA4B;QACrE,IAAI,CAAC,WAAW,CAAC,IAAI,GAAG,IAAI,CAAC,OAAO,EAAE,QAAQ,IAAI,OAAO,CAAC;QAC1D,IAAI,CAAC,WAAW,CAAC,eAAe,GAAG,CAAC,CAAC;QAErC,IAAI,CAAC,WAAW,CAAC,OAAO,GAAG,GAAG,EAAE;YAC9B,OAAO,CAAC,GAAG,CAAC,oCAAoC,CAAC,CAAC;YAClD,MAAM,SAAS,GAAQ,EAAE,CAAC;YAC1B,IAAI,IAAI,CAAC,aAAa,EAAE,CAAC;gBACvB,SAAS,CAAC,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC;YACxC,CAAC;YACD,IAAI,CAAC,IAAI,CAAC,oBAAoB,EAAE,SAAS,CAAC,CAAC;QAC7C,CAAC,CAAC;QAEF,IAAI,CAAC,WAAW,CAAC,QAAQ,GAAG,CAAC,KAAU,EAAE,EAAE;YACzC,MAAM,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC;YAE9B,OAAO,CAAC,GAAG,CAAC,2BAA2B,OAAO,CAAC,MAAM,UAAU,CAAC,CAAC;YACjE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;gBACxC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,MAAM,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,aAAa,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,GAAG,CAAC,CAAC;YACvF,CAAC;YAED,IAAI,IAAI,CAAC,YAAY,KAAK,0BAA0B,CAAC,qBAAqB,EAAE,CAAC;gBAC3E,sDAAsD;gBACtD,MAAM,UAAU,GAAG,OAAO,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;gBAC/C,MAAM,UAAU,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,WAAW,EAAE,CAAC,IAAI,EAAE,CAAC;gBACjE,IAAI,CAAC,sBAAsB,CAAC,UAAU,CAAC,CAAC;YAC1C,CAAC;iBAAM,IAAI,IAAI,CAAC,YAAY,KAAK,0BAA0B,CAAC,kBAAkB,EAAE,CAAC;gBAC/E,yBAAyB;gBACzB,IAAI,IAAI,CAAC,YAAY,EAAE,CAAC;oBACtB,YAAY,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;oBAChC,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;gBAC3B,CAAC;gBACD,MAAM,KAAK,GAAG,IAAI,CAAC,OAAO,EAAE,kBAAkB,CAAC;gBAC/C,OAAO,CAAC,GAAG,CAAC,IAAI,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE,2DAA2D,EAAE,KAAK,CAAC,CAAC;gBAC5G,IAAI,CAAC,YAAY,GAAG,MAAM,CAAC,UAAU,CAAC,GAAG,EAAE;oBACzC,OAAO,CAAC,GAAG,CAAC,IAAI,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE,0CAA0C,EAAE,KAAK,CAAC,CAAC;oBAC3F,IAAI,IAAI,CAAC,WAAW,EAAE,CAAC;wBACrB,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,CAAC;oBAC1B,CAAC;gBACH,CAAC,EAAE,KAAK,CAAC,CAAC;gBAEV,iGAAiG;gBACjG,oDAAoD;gBACpD,IAAI,CAAC,aAAa,GAAG,EAAE,CAAC,CAAC,4CAA4C;gBACrE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;oBACxC,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC;wBACvB,MAAM,UAAU,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,IAAI,EAAE,CAAC;wBACnD,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;wBACpC,OAAO,CAAC,GAAG,CAAC,4CAA4C,UAAU,GAAG,CAAC,CAAC;oBACzE,CAAC;gBACH,CAAC;YACH,CAAC;QACH,CAAC,CAAC;QAEF,IAAI,CAAC,WAAW,CAAC,OAAO,GAAG,CAAC,KAAU,EAAE,EAAE;YACxC,IAAI,KAAK,CAAC,KAAK,KAAK,WAAW,IAAI,IAAI,CAAC,aAAa,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;gBACnE,qCAAqC;gBACrC,4FAA4F;gBAC5F,IAAK,IAAI,CAAC,OAAO,EAAE,OAAO,IAAI,IAAI,CAAC,eAAe,EAAE,CAAC;oBACnD,uEAAuE;oBACvE,IAAI,CAAC,mBAAmB,EAAE,CAAC;oBAC3B,OAAM;gBACR,CAAC;qBAAI,CAAC;oBACJ,gDAAgD;oBAChD,OAAO,CAAC,GAAG,CAAC,+FAA+F,CAAC,CAAC;oBAC7G,IAAI,CAAC,WAAW,EAAE,KAAK,EAAE,CAAA;oBACzB,OAAM;gBACR,CAAC;YAEH,CAAC;YACD,OAAO,CAAC,KAAK,CAAC,qCAAqC,KAAK,CAAC,KAAK,cAAc,IAAI,CAAC,aAAa,GAAG,CAAC,CAAC;YACnG,IAAI,KAAK,CAAC,KAAK,KAAK,WAAW,IAAI,IAAI,CAAC,aAAa,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;gBACjE,qDAAqD;gBACrD,OAAO,CAAC,GAAG,CAAC,yDAAyD,CAAC,CAAA;gBACtE,IAAI,CAAC,mBAAmB,EAAE,CAAC;YAC7B,CAAC;iBAAI,CAAC;gBACJ,MAAM,SAAS,GAAQ;oBACrB,OAAO,EAAE,6BAA6B,KAAK,CAAC,KAAK,EAAE;oBACnD,IAAI,EAAE,CAAC;iBACR,CAAC;gBACF,IAAI,IAAI,CAAC,aAAa,EAAE,CAAC;oBACvB,SAAS,CAAC,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC;gBACxC,CAAC;gBACD,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC;YAClC,CAAC;QACH,CAAC,CAAC;QAEF,IAAI,CAAC,WAAW,CAAC,KAAK,GAAG,GAAG,EAAE;YAC5B,OAAO,CAAC,GAAG,CAAC,wCAAwC,IAAI,CAAC,YAAY,EAAE,EAAE,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC;YAClH,IAAI,IAAI,CAAC,YAAY,KAAK,0BAA0B,CAAC,qBAAqB,IAAI,IAAI,CAAC,eAAe,EAAE,CAAC;gBACnG,yGAAyG;gBACzG,IAAI,CAAC,WAAW,CAAC,0BAA0B,CAAC,kBAAkB,CAAC,CAAC;gBAChE,IAAI,CAAC,gBAAgB,EAAE,CAAC;gBACxB,OAAM;YACR,CAAC;YAED,IAAI,IAAI,CAAC,YAAY,KAAK,0BAA0B,CAAC,qBAAqB,EAAE,CAAC;gBAC3E,6DAA6D;gBAC7D,IAAI,IAAI,CAAC,QAAQ,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE,CAAC;oBAC3C,UAAU,CAAC,GAAG,EAAE;wBACd,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;4BAClB,sGAAsG;4BACtG,IAAI,CAAC,gBAAgB,EAAE,CAAC;wBAC1B,CAAC;oBACH,CAAC,EAAE,GAAG,CAAC,CAAC;gBACV,CAAC;YACH,CAAC;iBAAM,IAAI,IAAI,CAAC,YAAY,KAAK,0BAA0B,CAAC,kBAAkB,EAAE,CAAC;gBAC/E,gDAAgD;gBAChD,IAAI,CAAC,mBAAmB,EAAE,CAAC;YAC7B,CAAC;QACH,CAAC,CAAC;IACJ,CAAC;IAEO,sBAAsB,CAAC,UAAkB;QAC/C,MAAM,OAAO,GAAG,IAAI,CAAC,OAAO,EAAE,OAAO,EAAE,WAAW,EAAE,CAAC;QAErD,IAAI,CAAC,OAAO,EAAE,CAAC;YACb,iEAAiE;YACjE,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC;YAC5B,IAAI,CAAC,yBAAyB,CAAC,EAAE,CAAC,CAAC;YACnC,OAAO;QACT,CAAC;QAED,IAAI,UAAU,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE,CAAC;YACjC,OAAO,CAAC,GAAG,CAAC,2BAA2B,OAAO,aAAa,CAAC,CAAC;YAC7D,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC;YAE5B,gDAAgD;YAChD,MAAM,YAAY,GAAG,UAAU,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;YACjD,MAAM,YAAY,GAAG,UAAU,CAAC,SAAS,CAAC,YAAY,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC,IAAI,EAAE,CAAC;YAEhF,IAAI,CAAC,yBAAyB,CAAC,YAAY,CAAC,CAAC;QAC/C,CAAC;IACH,CAAC;IAEO,yBAAyB,CAAC,WAAmB;QACnD,IAAI,CAAC,gBAAgB,GAAG,WAAW,CAAC;QACpC,IAAI,CAAC,aAAa,GAAG,EAAE,CAAC;QACxB,mEAAmE;QAEnE,MAAM,SAAS,GAAQ;YACrB,OAAO,EAAE,IAAI,CAAC,OAAO,EAAE,OAAO,IAAI,EAAE;YACpC,SAAS,EAAE,IAAI,CAAC,GAAG,EAAE;SACtB,CAAC;QACF,IAAI,IAAI,CAAC,aAAa,EAAE,CAAC;YACvB,SAAS,CAAC,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC;QACxC,CAAC;QACD,IAAI,CAAC,IAAI,CAAC,mBAAmB,EAAE,SAAS,CAAC,CAAC;QAE1C,qCAAqC;QACrC,IAAI,IAAI,CAAC,OAAO,EAAE,YAAY,KAAK,KAAK,EAAE,CAAC;YACzC,IAAI,CAAC,qBAAqB,EAAE,CAAC;QAC/B,CAAC;QAED,0DAA0D;QAC1D,IAAI,IAAI,CAAC,WAAW,EAAE,CAAC;YACrB,mCAAmC;YACnC,IAAI,IAAI,CAAC,YAAY,EAAE,CAAC;gBACtB,YAAY,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;gBAChC,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;YAC3B,CAAC;YACD,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,CAAC;YACxB,gEAAgE;QAClE,CAAC;IACH,CAAC;IAEO,qBAAqB;QAC3B,iFAAiF;QACjF,MAAM,YAAY,GAAG,IAAI,CAAC,MAAM,CAAC,YAAY,IAAK,MAAc,CAAC,kBAAkB,CAAC,EAAE,CAAC;QAEvF,sCAAsC;QACtC,MAAM,UAAU,GAAG,YAAY,CAAC,gBAAgB,EAAE,CAAC;QACnD,MAAM,QAAQ,GAAG,YAAY,CAAC,UAAU,EAAE,CAAC;QAE3C,UAAU,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;QAC7B,QAAQ,CAAC,OAAO,CAAC,YAAY,CAAC,WAAW,CAAC,CAAC;QAE3C,8DAA8D;QAC9D,UAAU,CAAC,SAAS,CAAC,KAAK,GAAG,IAAI,CAAC,CAAC,UAAU;QAC7C,UAAU,CAAC,IAAI,GAAG,MAAM,CAAC;QAEzB,+DAA+D;QAC/D,MAAM,GAAG,GAAG,YAAY,CAAC,WAAW,CAAC;QACrC,QAAQ,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;QACrC,QAAQ,CAAC,IAAI,CAAC,uBAAuB,CAAC,GAAG,EAAE,GAAG,GAAG,KAAK,CAAC,CAAC,CAAC,eAAe;QACxE,QAAQ,CAAC,IAAI,CAAC,uBAAuB,CAAC,IAAI,EAAE,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,eAAe;QACxE,QAAQ,CAAC,IAAI,CAAC,4BAA4B,CAAC,IAAI,EAAE,GAAG,GAAG,GAAG,CAAC,CAAC,CAAC,gBAAgB;QAE7E,iBAAiB;QACjB,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QACtB,UAAU,CAAC,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC;IAC7B,CAAC;IAEO,mBAAmB;QACzB,iCAAiC;QACjC,MAAM,UAAU,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,CAAC;QAEvD,kDAAkD;QAClD,MAAM,SAAS,GAAG,IAAI,CAAC,gBAAgB,CAAC,CAAC;YACvC,GAAG,IAAI,CAAC,gBAAgB,IAAI,UAAU,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC;YACjD,UAAU,CAAC;QAEb,OAAO,CAAC,GAAG,CAAC,0CAA0C,IAAI,CAAC,gBAAgB,eAAe,UAAU,iBAAiB,SAAS,GAAG,CAAC,CAAC;QAEnI,mCAAmC;QACnC,IAAI,IAAI,CAAC,OAAO,EAAE,YAAY,KAAK,KAAK,EAAE,CAAC;YACzC,IAAI,CAAC,mBAAmB,EAAE,CAAC;QAC7B,CAAC;QAED,MAAM,SAAS,GAAQ;YACrB,IAAI,EAAE,SAAS;YACf,OAAO,EAAE,IAAI;SACd,CAAC;QACF,IAAI,IAAI,CAAC,aAAa,EAAE,CAAC;YACvB,SAAS,CAAC,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC;QACxC,CAAC;QAED,IAAI,CAAC,IAAI,CAAC,qBAAqB,EAAE,SAAS,CAAC,CAAC;QAC5C,IAAI,CAAC,OAAO,EAAE,CAAC;IACjB,CAAC;IAEO,mBAAmB;QACzB,+EAA+E;QAC/E,MAAM,YAAY,GAAG,IAAI,CAAC,MAAM,CAAC,YAAY,IAAK,MAAc,CAAC,kBAAkB,CAAC,EAAE,CAAC;QAEvF,sCAAsC;QACtC,MAAM,UAAU,GAAG,YAAY,CAAC,gBAAgB,EAAE,CAAC;QACnD,MAAM,QAAQ,GAAG,YAAY,CAAC,UAAU,EAAE,CAAC;QAE3C,UAAU,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;QAC7B,QAAQ,CAAC,OAAO,CAAC,YAAY,CAAC,WAAW,CAAC,CAAC;QAE3C,8EAA8E;QAC9E,UAAU,CAAC,SAAS,CAAC,KAAK,GAAG,GAAG,CAAC,CAAC,oCAAoC;QACtE,UAAU,CAAC,IAAI,GAAG,MAAM,CAAC;QAEzB,iEAAiE;QACjE,MAAM,GAAG,GAAG,YAAY,CAAC,WAAW,CAAC;QACrC,QAAQ,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;QACrC,QAAQ,CAAC,IAAI,CAAC,uBAAuB,CAAC,GAAG,EAAE,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,gBAAgB;QACxE,QAAQ,CAAC,IAAI,CAAC,uBAAuB,CAAC,IAAI,EAAE,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,iBAAiB;QAC1E,QAAQ,CAAC,IAAI,CAAC,4BAA4B,CAAC,IAAI,EAAE,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC,iBAAiB;QAE/E,iBAAiB;QACjB,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QACtB,UAAU,CAAC,IAAI,CAAC,GAAG,GAAG,IAAI,CAAC,CAAC;IAC9B,CAAC;IAGO,gBAAgB;QACtB,IAAI,CAAC,IAAI,CAAC,WAAW;YAAE,OAAO;QAE9B,gDAAgD;QAChD,IAAI,CAAC,WAAW,CAAC,UAAU,GAAG,IAAI,CAAC,YAAY,KAAK,0BAA0B,CAAC,kBAAkB,CAAC;QAElG,IAAI,CAAC;YACH,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,CAAC;YAEzB,gDAAgD;YAChD,IAAI,IAAI,CAAC,YAAY,KAAK,0BAA0B,CAAC,kBAAkB,EAAE,CAAC;gBACxE,4GAA4G;gBAC5G,MAAM,gBAAgB,GAAG,IAAI,CAAC,gBAAgB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,OAAO,EAAE,kBAAkB,CAAC,CAAC,CAAC,KAAK,CAAC;gBACrG,OAAO,CAAC,GAAG,CAAC,IAAI,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE,0DAA0D,EAAE,gBAAgB,CAAC,CAAC;gBACtH,IAAI,CAAC,YAAY,GAAG,MAAM,CAAC,UAAU,CAAC,GAAG,EAAE;oBACvC,OAAO,CAAC,GAAG,CAAC,IAAI,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE,0CAA0C,EAAE,gBAAgB,CAAC,CAAC;oBACxG,IAAI,IAAI,CAAC,WAAW,EAAE,CAAC;wBACrB,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,CAAC;oBAC1B,CAAC;gBACH,CAAC,EAAE,gBAAgB,CAAC,CAAC;YACvB,CAAC;QACH,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,OAAO,CAAC,KAAK,CAAC,4CAA4C,EAAE,KAAK,CAAC,CAAC;YACnE,yDAAyD;QAC3D,CAAC;IACH,CAAC;IAEO,OAAO;QACb,IAAI,CAAC,eAAe,GAAG,KAAK,CAAC;QAC7B,IAAI,CAAC,gBAAgB,GAAG,EAAE,CAAC;QAC3B,IAAI,CAAC,aAAa,GAAG,EAAE,CAAC;QACxB,IAAI,IAAI,CAAC,YAAY,EAAE,CAAC;YACtB,YAAY,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;YAChC,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;QAC3B,CAAC;QACD,IAAI,CAAC,WAAW,CAAC,0BAA0B,CAAC,IAAI,CAAC,CAAC;QAClD,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;QACtB,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;QAE1B,IAAI,IAAI,CAAC,WAAW,EAAE,CAAC;YACrB,IAAI,CAAC,WAAW,CAAC,IAAI,EAAE,CAAC;QAC1B,CAAC;IACH,CAAC;IAED,qBAAqB;IACrB,KAAK,CAAC,QAAQ,CAAC,OAAuD;QACpE,OAAO,CAAC,GAAG,CAAC,yCAAyC,EAAE,OAAO,CAAC,CAAC;QAEhE,yEAAyE;QACzE,IAAI,CAAC,mBAAmB,EAAE,CAAC;QAC3B,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,aAAa,GAAG,OAAO,CAAC,MAAM,IAAI,SAAS,CAAC;QACjD,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;QACrB,IAAI,CAAC,eAAe,GAAG,KAAK,CAAC;QAC7B,IAAI,CAAC,gBAAgB,GAAG,EAAE,CAAC;QAC3B,IAAI,CAAC,aAAa,GAAG,EAAE,CAAC;QAExB,0BAA0B;QAC1B,IAAI,OAAO,CAAC,OAAO,KAAK,IAAI,IAAI,OAAO,CAAC,OAAO,KAAK,SAAS,IAAI,OAAO,CAAC,OAAO,CAAC,IAAI,EAAE,KAAK,EAAE,EAAE,CAAC;YAC/F,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;QAC7C,CAAC;QAED,8CAA8C;QAC9C,IAAI,OAAO,CAAC,OAAO,EAAE,CAAC;YACpB,IAAI,CAAC,WAAW,CAAC,0BAA0B,CAAC,qBAAqB,CAAC,CAAC;QACrE,CAAC;aAAM,CAAC;YACN,IAAI,CAAC,WAAW,CAAC,0BAA0B,CAAC,kBAAkB,CAAC,CAAC;QAClE,CAAC;QAED,IAAI,CAAC,gBAAgB,EAAE,CAAC;QACxB,IAAI,CAAC,gBAAgB,EAAE,CAAC;IAC1B,CAAC;IAED,KAAK,CAAC,UAAU;QACd,OAAO,CAAC,GAAG,CAAC,6BAA6B,CAAC,CAAC;QAC3C,IAAI,CAAC,OAAO,EAAE,CAAC;IACjB,CAAC;IAED,KAAK,CAAC,uBAAuB;QAC3B,IAAI,CAAC;YACH,gCAAgC;YAChC,MAAM,MAAM,GAAG,MAAM,SAAS,CAAC,YAAY,CAAC,YAAY,CAAC,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC,CAAC;YAC1E,MAAM,CAAC,SAAS,EAAE,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,CAAC;YAElD,OAAO;gBACL,MAAM,EAAE,SAAS;gBACjB,OAAO,EAAE,IAAI;gBACb,WAAW,EAAE,IAAI;aAClB,CAAC;QACJ,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,OAAO,CAAC,KAAK,CAAC,mCAAmC,EAAE,KAAK,CAAC,CAAC;YAC1D,OAAO;gBACL,MAAM,EAAE,QAAQ;gBAChB,OAAO,EAAE,KAAK;gBACd,WAAW,EAAE,IAAI;aAClB,CAAC;QACJ,CAAC;IACH,CAAC;IAED,KAAK,CAAC,qBAAqB;QACzB,8CAA8C;QAC9C,MAAM,eAAe,GAAe;YAClC,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,cAAc,EAAE;YACvC,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,cAAc,EAAE;YACvC,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,iBAAiB,EAAE;YAC1C,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,kBAAkB,EAAE;YAC3C,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,iBAAiB,EAAE;YAC1C,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,iBAAiB,EAAE;YAC1C,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,kBAAkB,EAAE;YAC3C,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,iBAAiB,EAAE;YAC1C,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,qBAAqB,EAAE;YAC9C,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,uBAAuB,EAAE;YAChD,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,UAAU,EAAE;YACnC,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,QAAQ,EAAE;YACjC,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,sBAAsB,EAAE;YAC/C,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,uBAAuB,EAAE;YAChD,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,SAAS,EAAE;YAClC,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,uBAAuB,EAAE;YAChD,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,eAAe,EAAE;YACxC,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE;YAC/B,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,QAAQ,EAAE;YACjC,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,qBAAqB,EAAE;YAC9C,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,SAAS,EAAE;YAClC,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,QAAQ,EAAE;YACjC,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,WAAW,EAAE;YACpC,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,SAAS,EAAE;YAClC,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,SAAS,EAAE;YAClC,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,QAAQ,EAAE;YACjC,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,OAAO,EAAE;YAChC,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,WAAW,EAAE;YACpC,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,UAAU,EAAE;YACnC,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,QAAQ,EAAE;YACjC,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,WAAW,EAAE;YACpC,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,UAAU,EAAE;YACnC,EAAE,IAAI,EAAE,OAAO,EAAE,IAAI,EAAE,WAAW,EAAE;SACrC,CAAC;QAEF,OAAO,eAAe,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;IACtE,CAAC;CACF;AAED,eAAe,IAAI,gCAAgC,EAAE,CAAC","sourcesContent":["// STRATEGY:\n// while keyword, we can do non-continuous recognition\n// when we see it, save the \"rest\" (after keyword) in the buffer\n// and restart recognition in continuous mode, under the now \"recognizing speech\"\n// at this point, we keep going until the timeout ... and the result will have a LIST of results\n// which we need to concatenate, and add to the potential text in the buffer. That's the final result (and we can do that \n// in the onend handler).\nimport { EventEmitter } from 'expo';\nimport { \n  ExpoKeywordBasedRecognizerModuleEvents, \n  KeywordRecognizerOptions, \n  Language, \n  PermissionResponse,\n  KeywordRecognizerStateEnum\n} from './ExpoKeywordBasedRecognizer.types';\n\n// Web Speech API types\ninterface SpeechRecognition extends EventTarget {\n  continuous: boolean;\n  interimResults: boolean;\n  lang: string;\n  maxAlternatives: number;\n  serviceURI: string;\n  grammars: any;\n  start(): void;\n  stop(): void;\n  abort(): void;\n  onaudiostart: ((this: SpeechRecognition, ev: Event) => any) | null;\n  onaudioend: ((this: SpeechRecognition, ev: Event) => any) | null;\n  onend: ((this: SpeechRecognition, ev: Event) => any) | null;\n  onerror: ((this: SpeechRecognition, ev: any) => any) | null;\n  onnomatch: ((this: SpeechRecognition, ev: any) => any) | null;\n  onresult: ((this: SpeechRecognition, ev: any) => any) | null;\n  onsoundstart: ((this: SpeechRecognition, ev: Event) => any) | null;\n  onsoundend: ((this: SpeechRecognition, ev: Event) => any) | null;\n  onspeechstart: ((this: SpeechRecognition, ev: Event) => any) | null;\n  onspeechend: ((this: SpeechRecognition, ev: Event) => any) | null;\n  onstart: ((this: SpeechRecognition, ev: Event) => any) | null;\n}\n\ninterface SpeechRecognitionConstructor {\n  new (): SpeechRecognition;\n}\n\ndeclare global {\n  interface Window {\n    SpeechRecognition: SpeechRecognitionConstructor;\n    webkitSpeechRecognition: SpeechRecognitionConstructor;\n  }\n}\n\n// Use the same enum as the native implementation\n\nclass ExpoKeywordBasedRecognizerModule extends EventEmitter<ExpoKeywordBasedRecognizerModuleEvents> {\n  private recognition: SpeechRecognition | null = null;\n  private isActive = false;\n  private currentState = KeywordRecognizerStateEnum.IDLE;\n  private options: KeywordRecognizerOptions | null = null;\n  private silenceTimer: number | null = null;\n  private keywordDetected = false;\n  private transcriptBuffer = '';\n  private speechResults: string[] = []; // Store all speech recognition results\n  private currentFlowId: string | null = null; // Track current flow ID\n\n  constructor() {\n    super();\n    // Defer browser support check to avoid accessing window during module initialization\n  }\n\n  private checkBrowserSupport(): void {\n    if (!this.getSpeechRecognition()) {\n      console.warn('Speech recognition is not supported in this browser');\n    }\n  }\n\n  private getSpeechRecognition(): SpeechRecognitionConstructor | null {\n    // Check if we're in a browser environment before accessing window\n    if (typeof window === 'undefined') {\n      return null;\n    }\n    return window.SpeechRecognition || window.webkitSpeechRecognition || null;\n  }\n\n  private updateState(newState: KeywordRecognizerStateEnum): void {\n    this.currentState = newState;\n    console.log(`🟡 Web Speech: Updating state to ${newState}, flowId: ${this.currentFlowId}`);\n    \n    const eventData: any = { state: newState };\n    if (this.currentFlowId) {\n      eventData.flowId = this.currentFlowId;\n    }\n    this.emit('onStateChange', eventData);\n  }\n\n  private setupRecognition(): void {\n    const SpeechRecognitionClass = this.getSpeechRecognition();\n    if (!SpeechRecognitionClass) {\n      throw new Error('Speech recognition is not supported in this browser');\n    }\n\n    this.recognition = new SpeechRecognitionClass();\n    // Set continuous mode based on current state\n    this.recognition.continuous = this.currentState === KeywordRecognizerStateEnum.RECOGNIZING_SPEECH;\n    this.recognition.interimResults = false; // No interim results needed\n    this.recognition.lang = this.options?.language ?? 'en-US';\n    this.recognition.maxAlternatives = 1;\n\n    this.recognition.onstart = () => {\n      console.log('🟢 Web Speech: Recognition started');\n      const eventData: any = {};\n      if (this.currentFlowId) {\n        eventData.flowId = this.currentFlowId;\n      }\n      this.emit('onRecognitionStart', eventData);\n    };\n\n    this.recognition.onresult = (event: any) => {\n      const results = event.results;\n      \n      console.log(`🟢 Web Speech: Received ${results.length} results`);\n      for (let i = 0; i < results.length; i++) {\n        console.log(` - ${i}: \"${results[i][0].transcript}\" (final: ${results[i].isFinal})`);\n      }\n\n      if (this.currentState === KeywordRecognizerStateEnum.LISTENING_FOR_KEYWORD) {\n        // For keyword detection, we only need the last result\n        const lastResult = results[results.length - 1];\n        const transcript = lastResult[0].transcript.toLowerCase().trim();\n        this.handleKeywordDetection(transcript);\n      } else if (this.currentState === KeywordRecognizerStateEnum.RECOGNIZING_SPEECH) {\n        // Restart silence timer \n        if (this.silenceTimer) {\n          clearTimeout(this.silenceTimer);\n          this.silenceTimer = null;\n        }\n        const delay = this.options?.maxSilenceDuration;\n        console.log(`[${new Date().toISOString()}] 🟢 Web Speech: RESTARTING TIMER on speech received for `, delay);\n        this.silenceTimer = window.setTimeout(() => {\n          console.log(`[${new Date().toISOString()}] 🟡 Web Speech: Silence timeout reached`, delay);\n          if (this.recognition) {\n            this.recognition.stop();\n          }\n        }, delay);\n\n        // JOSEP: Should we not save anything? if it's continuous...I think we'll get the all at the end?\n        // For speech recognition, collect all final results\n        this.speechResults = []; // Reset results for new recognition session\n        for (let i = 0; i < results.length; i++) {\n          if (results[i].isFinal) {\n            const transcript = results[i][0].transcript.trim();\n            this.speechResults.push(transcript);\n            console.log(`🟢 Web Speech: Added to speech results: \"${transcript}\"`);\n          }\n        }\n      }\n    };\n\n    this.recognition.onerror = (event: any) => {\n      if( event.error === 'no-speech' && this.speechResults.length === 0) {\n        // No speech detected and no results.\n        // unless we were already after recognizing the keyword, we want to continue listening in...\n        if ( this.options?.keyword && this.keywordDetected) {\n          // If we were recognizing speech, we can consider it a no-speech event?\n          this.processFinalResults();\n          return\n        }else{\n          // We need to continue listening for the keyword\n          console.log('🟢 Web Speech: Restarting recognition since we do not even have the keyword!!!!!!!!!!!!!!!!!!');\n          this.recognition?.abort()\n          return\n        }\n\n      }\n      console.error(`🔴 Web Speech: Recognition error: ${event.error} (results: ${this.speechResults})`);\n      if( event.error === 'no-speech' && this.speechResults.length > 0) {\n        // Empty last result, but we have some speech results\n        console.log('🔴 Web Speech: No speech detected, but we have results ')\n        this.processFinalResults();\n      }else{\n        const eventData: any = {\n          message: `Speech recognition error: ${event.error}`,\n          code: 0\n        };\n        if (this.currentFlowId) {\n          eventData.flowId = this.currentFlowId;\n        }\n        this.emit('onError', eventData);\n      }\n    };\n\n    this.recognition.onend = () => {\n      console.log(`🟡 Web Speech: Recognition ended for ${this.currentState}`, this.currentState, this.keywordDetected);\n      if( this.currentState === KeywordRecognizerStateEnum.LISTENING_FOR_KEYWORD && this.keywordDetected) {\n        // pickup the fact that we just finished detecting the keyword, therefor transition to recognizing speech\n        this.updateState(KeywordRecognizerStateEnum.RECOGNIZING_SPEECH);\n        this.startRecognition();\n        return\n      }\n\n      if (this.currentState === KeywordRecognizerStateEnum.LISTENING_FOR_KEYWORD) {\n        // For keyword detection, restart recognition if still active\n        if (this.isActive && !this.keywordDetected) {\n          setTimeout(() => {\n            if (this.isActive) {\n              // console.log('🟢 Web Speech: Restarting recognition for keyword detection !!!!!!!!!!!!!!!!!!!!!!!');\n              this.startRecognition();\n            }\n          }, 100);\n        }\n      } else if (this.currentState === KeywordRecognizerStateEnum.RECOGNIZING_SPEECH) {\n        // For speech recognition, process final results\n        this.processFinalResults();\n      }\n    };\n  }\n\n  private handleKeywordDetection(transcript: string): void {\n    const keyword = this.options?.keyword?.toLowerCase();\n    \n    if (!keyword) {\n      // No keyword specified, immediately switch to speech recognition\n      this.keywordDetected = true;\n      this.switchToSpeechRecognition('');\n      return;\n    }\n\n    if (transcript.includes(keyword)) {\n      console.log(`🟢 Web Speech: Keyword \"${keyword}\" detected!`);\n      this.keywordDetected = true;\n      \n      // Extract text after keyword and save to buffer\n      const keywordIndex = transcript.indexOf(keyword);\n      const afterKeyword = transcript.substring(keywordIndex + keyword.length).trim();\n      \n      this.switchToSpeechRecognition(afterKeyword);\n    }\n  }\n\n  private switchToSpeechRecognition(initialText: string): void {\n    this.transcriptBuffer = initialText;\n    this.speechResults = [];\n    // this.updateState(KeywordRecognizerStateEnum.RECOGNIZING_SPEECH);\n    \n    const eventData: any = { \n      keyword: this.options?.keyword || '',\n      timestamp: Date.now()\n    };\n    if (this.currentFlowId) {\n      eventData.flowId = this.currentFlowId;\n    }\n    this.emit('onKeywordDetected', eventData);\n    \n    // Play sound notification if enabled\n    if (this.options?.soundEnabled !== false) {\n      this.playNotificationSound();\n    }\n    \n    // Stop current recognition and restart in continuous mode\n    if (this.recognition) {\n      // Reset any existing silence timer\n      if (this.silenceTimer) {\n        clearTimeout(this.silenceTimer);\n        this.silenceTimer = null;\n      }\n      this.recognition.stop();\n      // Recognition will restart in continuous mode via onend handler\n    }\n  }\n\n  private playNotificationSound(): void {\n    // Create and play a notification sound using Web Audio API (similar to iOS 1113)\n    const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\n    \n    // Create oscillator for the main tone\n    const oscillator = audioContext.createOscillator();\n    const gainNode = audioContext.createGain();\n    \n    oscillator.connect(gainNode);\n    gainNode.connect(audioContext.destination);\n    \n    // Configure the sound - higher pitch like iOS begin recording\n    oscillator.frequency.value = 1047; // C6 note\n    oscillator.type = 'sine';\n    \n    // Create envelope for the sound - quick attack, short duration\n    const now = audioContext.currentTime;\n    gainNode.gain.setValueAtTime(0, now);\n    gainNode.gain.linearRampToValueAtTime(0.4, now + 0.005); // Quick attack\n    gainNode.gain.linearRampToValueAtTime(0.35, now + 0.03); // Slight decay\n    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1); // Quick release\n    \n    // Play the sound\n    oscillator.start(now);\n    oscillator.stop(now + 0.1);\n  }\n\n  private processFinalResults(): void {\n    // Concatenate all speech results\n    const speechText = this.speechResults.join(' ').trim();\n    \n    // Combine with buffer text from keyword detection\n    const finalText = this.transcriptBuffer ? \n      `${this.transcriptBuffer} ${speechText}`.trim() : \n      speechText;\n    \n    console.log(`🟢 Web Speech: Final result - buffer: \"${this.transcriptBuffer}\", speech: \"${speechText}\", combined: \"${finalText}\"`);\n    \n    // Play completion sound if enabled\n    if (this.options?.soundEnabled !== false) {\n      this.playCompletionSound();\n    }\n    \n    const eventData: any = {\n      text: finalText,\n      isFinal: true\n    };\n    if (this.currentFlowId) {\n      eventData.flowId = this.currentFlowId;\n    }\n\n    this.emit('onRecognitionResult', eventData);\n    this.cleanup();\n  }\n\n  private playCompletionSound(): void {\n    // Create and play a completion sound using Web Audio API (similar to iOS 1114)\n    const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\n    \n    // Create oscillator for the main tone\n    const oscillator = audioContext.createOscillator();\n    const gainNode = audioContext.createGain();\n    \n    oscillator.connect(gainNode);\n    gainNode.connect(audioContext.destination);\n    \n    // Configure the sound - lower frequency for completion like iOS end recording\n    oscillator.frequency.value = 523; // C5 note (octave lower than start)\n    oscillator.type = 'sine';\n    \n    // Create envelope for the sound - softer attack, slightly longer\n    const now = audioContext.currentTime;\n    gainNode.gain.setValueAtTime(0, now);\n    gainNode.gain.linearRampToValueAtTime(0.3, now + 0.01); // Softer attack\n    gainNode.gain.linearRampToValueAtTime(0.25, now + 0.05); // Gentle sustain\n    gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.12); // Smooth release\n    \n    // Play the sound\n    oscillator.start(now);\n    oscillator.stop(now + 0.12);\n  }\n\n\n  private startRecognition(): void {\n    if (!this.recognition) return;\n    \n    // Update continuous mode based on current state\n    this.recognition.continuous = this.currentState === KeywordRecognizerStateEnum.RECOGNIZING_SPEECH;\n    \n    try {\n      this.recognition.start();\n      \n      // Set silence timer for speech recognition mode\n      if (this.currentState === KeywordRecognizerStateEnum.RECOGNIZING_SPEECH) {\n        // if we have somethin in the buffer already, we do normal silence delay, if we have nothing, we wait longer\n        const conditionalDelay = this.transcriptBuffer.length > 0 ? this.options?.maxSilenceDuration : 10000;\n        console.log(`[${new Date().toISOString()}] 🟢 Web Speech: Starting TIMER on StartRecognition for `, conditionalDelay);\n        this.silenceTimer = window.setTimeout(() => {\n            console.log(`[${new Date().toISOString()}] 🟡 Web Speech: Silence timeout reached`, conditionalDelay);\n          if (this.recognition) {\n            this.recognition.stop();\n          }\n        }, conditionalDelay);\n      }\n    } catch (error) {\n      console.error('🔴 Web Speech: Error starting recognition:', error);\n      // Recognition might already be running, ignore the error\n    }\n  }\n\n  private cleanup(): void {\n    this.keywordDetected = false;\n    this.transcriptBuffer = '';\n    this.speechResults = [];\n    if (this.silenceTimer) {\n      clearTimeout(this.silenceTimer);\n      this.silenceTimer = null;\n    }\n    this.updateState(KeywordRecognizerStateEnum.IDLE);\n    this.isActive = false;\n    this.currentFlowId = null;\n    \n    if (this.recognition) {\n      this.recognition.stop();\n    }\n  }\n\n  // Public API methods\n  async activate(options: KeywordRecognizerOptions & { flowId?: string }): Promise<void> {\n    console.log('🔴 Web Speech: Activating with options:', options);\n    \n    // Check browser support when actually using the module, and not building\n    this.checkBrowserSupport();    \n    this.options = options;\n    this.currentFlowId = options.flowId || 'unknown';\n    this.isActive = true;\n    this.keywordDetected = false;\n    this.transcriptBuffer = '';\n    this.speechResults = [];\n\n    // Check for empty keyword\n    if (options.keyword !== null && options.keyword !== undefined && options.keyword.trim() === '') {\n      throw new Error('Keyword cannot be empty');\n    }\n\n    // Set initial state based on keyword presence\n    if (options.keyword) {\n      this.updateState(KeywordRecognizerStateEnum.LISTENING_FOR_KEYWORD);\n    } else {\n      this.updateState(KeywordRecognizerStateEnum.RECOGNIZING_SPEECH);\n    }\n    \n    this.setupRecognition();\n    this.startRecognition();\n  }\n\n  async deactivate(): Promise<void> {\n    console.log('🟡 Web Speech: Deactivating');\n    this.cleanup();\n  }\n\n  async requestPermissionsAsync(): Promise<PermissionResponse> {\n    try {\n      // Request microphone permission\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n      stream.getTracks().forEach(track => track.stop());\n      \n      return {\n        status: 'granted',\n        granted: true,\n        canAskAgain: true\n      };\n    } catch (error) {\n      console.error('🔴 Web Speech: Permission denied:', error);\n      return {\n        status: 'denied',\n        granted: false,\n        canAskAgain: true\n      };\n    }\n  }\n\n  async getAvailableLanguages(): Promise<Language[]> {\n    // Common languages supported by most browsers\n    const commonLanguages: Language[] = [\n      { code: 'en-US', name: 'English (US)' },\n      { code: 'en-GB', name: 'English (UK)' },\n      { code: 'es-ES', name: 'Spanish (Spain)' },\n      { code: 'es-MX', name: 'Spanish (Mexico)' },\n      { code: 'fr-FR', name: 'French (France)' },\n      { code: 'fr-CA', name: 'French (Canada)' },\n      { code: 'de-DE', name: 'German (Germany)' },\n      { code: 'it-IT', name: 'Italian (Italy)' },\n      { code: 'pt-BR', name: 'Portuguese (Brazil)' },\n      { code: 'pt-PT', name: 'Portuguese (Portugal)' },\n      { code: 'ja-JP', name: 'Japanese' },\n      { code: 'ko-KR', name: 'Korean' },\n      { code: 'zh-CN', name: 'Chinese (Simplified)' },\n      { code: 'zh-TW', name: 'Chinese (Traditional)' },\n      { code: 'ru-RU', name: 'Russian' },\n      { code: 'ar-SA', name: 'Arabic (Saudi Arabia)' },\n      { code: 'hi-IN', name: 'Hindi (India)' },\n      { code: 'th-TH', name: 'Thai' },\n      { code: 'pl-PL', name: 'Polish' },\n      { code: 'nl-NL', name: 'Dutch (Netherlands)' },\n      { code: 'sv-SE', name: 'Swedish' },\n      { code: 'da-DK', name: 'Danish' },\n      { code: 'no-NO', name: 'Norwegian' },\n      { code: 'fi-FI', name: 'Finnish' },\n      { code: 'tr-TR', name: 'Turkish' },\n      { code: 'he-IL', name: 'Hebrew' },\n      { code: 'cs-CZ', name: 'Czech' },\n      { code: 'hu-HU', name: 'Hungarian' },\n      { code: 'ro-RO', name: 'Romanian' },\n      { code: 'sk-SK', name: 'Slovak' },\n      { code: 'bg-BG', name: 'Bulgarian' },\n      { code: 'hr-HR', name: 'Croatian' },\n      { code: 'uk-UA', name: 'Ukrainian' },\n    ];\n\n    return commonLanguages.sort((a, b) => a.name.localeCompare(b.name));\n  }\n}\n\nexport default new ExpoKeywordBasedRecognizerModule();"]}