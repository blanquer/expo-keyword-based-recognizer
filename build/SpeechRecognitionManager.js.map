{"version":3,"file":"SpeechRecognitionManager.js","sourceRoot":"","sources":["../src/SpeechRecognitionManager.ts"],"names":[],"mappings":"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","sourcesContent":["import ExpoKeywordBasedRecognizerModule from './ExpoKeywordBasedRecognizerModule';\nimport { SpeechRecognitionFlow } from './SpeechRecognitionFlow';\nimport { \n  SpeechRecognitionManager as ISpeechRecognitionManager,\n  FlowActivationOptions \n} from './SpeechRecognitionTypes';\nimport { \n  KeywordRecognizerState, \n  KeywordRecognizerStateEnum,\n  PermissionResponse, \n  Language,\n  KeywordDetectionEvent,\n  RecognitionResult\n} from './ExpoKeywordBasedRecognizer.types';\n\ninterface FlowCallbacks {\n  onStateChange: ((state: KeywordRecognizerState) => void)[];\n  onKeywordDetected: ((event: KeywordDetectionEvent) => void)[];\n  onRecognitionResult: ((result: RecognitionResult) => void)[];\n  onError: ((error: Error) => void)[];\n}\n\nexport class SpeechRecognitionManager implements ISpeechRecognitionManager {\n  private static instance: SpeechRecognitionManager;\n  private flows: Map<string, SpeechRecognitionFlow> = new Map();\n  private activeFlow: SpeechRecognitionFlow | null = null;\n  private currentState: KeywordRecognizerState = { state: KeywordRecognizerStateEnum.IDLE };\n  private flowCallbacks: Map<string, FlowCallbacks> = new Map();\n\n  private constructor() {\n    this.setupEventRouting();\n  }\n\n  private setupEventRouting(): void {\n    // Set up centralized event routing based on flowId\n    ExpoKeywordBasedRecognizerModule.addListener('onStateChange', (event: any) => {\n      const { flowId, state } = event;\n      console.log('ðŸŸ£ SpeechRecognitionManager: Received state change event:', event);\n      this.currentState = { state }; // Extract just the state\n      \n      if (flowId) {\n        const callbacks = this.flowCallbacks.get(flowId)?.onStateChange || [];\n        console.log(`ðŸŸ£ SpeechRecognitionManager: Routing to ${callbacks.length} callbacks for flowId: ${flowId}`);\n        callbacks.forEach(callback => callback({ state }));\n      }\n    });\n\n    ExpoKeywordBasedRecognizerModule.addListener('onKeywordDetected', (event: any) => {\n      const { flowId, ...data } = event;\n      \n      if (flowId) {\n        const callbacks = this.flowCallbacks.get(flowId)?.onKeywordDetected || [];\n        callbacks.forEach(callback => callback(data));\n      }\n    });\n\n    ExpoKeywordBasedRecognizerModule.addListener('onRecognitionResult', (event: any) => {\n      const { flowId, ...data } = event;\n      \n      if (flowId) {\n        const callbacks = this.flowCallbacks.get(flowId)?.onRecognitionResult || [];\n        callbacks.forEach(callback => callback(data));\n      }\n    });\n\n    ExpoKeywordBasedRecognizerModule.addListener('onError', (event: any) => {\n      const { flowId, ...data } = event;\n      const error = new Error(data.message);\n      \n      if (flowId) {\n        const callbacks = this.flowCallbacks.get(flowId)?.onError || [];\n        callbacks.forEach(callback => callback(error));\n      }\n    });\n  }\n\n  static getInstance(): SpeechRecognitionManager {\n    if (!SpeechRecognitionManager.instance) {\n      SpeechRecognitionManager.instance = new SpeechRecognitionManager();\n    }\n    return SpeechRecognitionManager.instance;\n  }\n\n  registerFlow(flowId: string): SpeechRecognitionFlow {\n    if (this.flows.has(flowId)) {\n      throw new Error(`Flow with id \"${flowId}\" already exists`);\n    }\n    \n    // Initialize callback arrays for this flow\n    this.flowCallbacks.set(flowId, {\n      onStateChange: [],\n      onKeywordDetected: [],\n      onRecognitionResult: [],\n      onError: [],\n    });\n    \n    const flow = new SpeechRecognitionFlow(flowId, this);\n    this.flows.set(flowId, flow);\n    return flow;\n  }\n\n  unregisterFlow(flowId: string): void {\n    const flow = this.flows.get(flowId);\n    if (!flow) return;\n    \n    // If this is the active flow, deactivate it\n    if (this.activeFlow === flow) {\n      flow.deactivate();\n      this.activeFlow = null;\n    }\n    \n    // Callbacks will be cleaned up when we delete from flowCallbacks\n    \n    // Remove callback registrations\n    this.flowCallbacks.delete(flowId);\n    \n    this.flows.delete(flowId);\n  }\n\n  getActiveFlow(): SpeechRecognitionFlow | null {\n    return this.activeFlow;\n  }\n\n  getState(): KeywordRecognizerState {\n    return this.currentState;\n  }\n\n  isActive(): boolean {\n    return this.activeFlow !== null && this.currentState.state !== KeywordRecognizerStateEnum.IDLE;\n  }\n\n  async requestPermissions(): Promise<PermissionResponse> {\n    return ExpoKeywordBasedRecognizerModule.requestPermissionsAsync();\n  }\n\n  async getAvailableLanguages(): Promise<Language[]> {\n    return ExpoKeywordBasedRecognizerModule.getAvailableLanguages();\n  }\n\n  // Methods for flows to register callbacks\n  registerCallback(flowId: string, eventType: keyof FlowCallbacks, callback: any): () => void {\n    const flowCallbacks = this.flowCallbacks.get(flowId);\n    if (!flowCallbacks) {\n      throw new Error(`Flow \"${flowId}\" not found`);\n    }\n\n    flowCallbacks[eventType].push(callback);\n\n    // Return unsubscribe function\n    return () => {\n      const callbacks = this.flowCallbacks.get(flowId)?.[eventType];\n      if (callbacks) {\n        const index = callbacks.indexOf(callback);\n        if (index > -1) {\n          callbacks.splice(index, 1);\n        }\n      }\n    };\n  }\n\n  // Internal method called by flows\n  async _activateFlow(flow: SpeechRecognitionFlow, options: FlowActivationOptions): Promise<void> {\n    // If there's an active flow, deactivate it first\n    if (this.activeFlow && this.activeFlow !== flow) {\n      const previousFlow = this.activeFlow;\n      const previousOptions = previousFlow.getOptions();\n      \n      // Notify the previous flow it's being taken over\n      (previousFlow as any)._notifyTakenOver(flow.flowId);\n      \n      // Deactivate the current flow\n      await previousFlow.deactivate();\n      \n      // Call onInterrupted callback if it exists\n      if (previousOptions?.onInterrupted) {\n        previousOptions.onInterrupted();\n      }\n    }\n    \n    // Update flow state BEFORE activation so it's ready when events arrive\n    flow._setActive(true);\n    flow._setOptions(options);\n    this.activeFlow = flow;\n    \n    // Activate the new flow\n    const { onInterrupted, ...nativeOptions } = options;\n    const activationOptions = {\n      ...nativeOptions,\n      flowId: flow.flowId\n    };\n    \n    try {\n      await ExpoKeywordBasedRecognizerModule.activate(activationOptions);\n    } catch (error) {\n      // If activation fails, reset the flow state\n      flow._setActive(false);\n      flow._setOptions(null);\n      this.activeFlow = null;\n      throw error;\n    }\n  }\n}"]}